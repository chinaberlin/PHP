<textarea kp-markdown>

# 简单
>PHP开发过于简单,不知道不觉中写出的Web应用程序也可以正常运行。你会陶醉与这条毁灭之路。当然，刚开始你不会意识到这一点，因为你的站点看起来那么奇妙，站点运行良好，用户也满意。

# 问题
>当开始一个新的开发阶段时，现在你有一个更大的开发团队
>
1. 代码难以读懂
2. 做一个简单改变，必须更新N多个页面
3. 一个程序的修改，而实际你在较早时候也对这个文件做了大量修改， 没有同步程序
4. 站点受欢迎，访问量增加，你需要将代码迁移到最新的服务器，需要手动安装，而你发现文件路径，数据库名和密码已经被硬编码到许多文件中了

# 类和对象

> 拿建造房子举例来讲，类就是图纸，而对象就是根据图纸造出的房子

> 简单的说，类是用于生成对象的<span>代码</span>模版。

# 类的定义
> 类名可以是任意数字和字母的组合，但是不能以数字开头。

> [demo001](./demo/类与对象/001.php)

# 创建对象
> 如果类是生成对象的模版，那么对象是根据类中定义的模版所构造的数据，对象可以被说成是类的实例。

> 生成一个对象，需要使用关键字NEW，我们也可以叫做实例化一个对象

> 一个类可以生成了N个对象，但是所生成出来的是相同类型的不同对象。

> [demo001](./demo/类与对象/001.php)

# 对象的身份
> 在PHP脚本中创建的每个对象也有唯一的身份(在对象的生命周期中唯一)，PHP会在一个进程内重复使用这些身份来访问这些对象。

>  "#" 后面就是每个对象的内部标识符

> [demo001](./demo/类与对象/001.php)

# 类中的属性
> 类可以定义被称为属性的特定变量，也被称为成员变量，用来存放对象之间互不相同的数据。

> 类的属性和标准的变量很相似，不过必须在声明和赋值前加一个可见性的关键字,public private protected

> [demo002](./demo/类与对象/002.php)

# 访问类的属性
> 可以使用->字符，连接对象变量和属性名来访问属性变量，也可以动态改变对象属性的值

> [demo002](./demo/类与对象/002.php)

# 使用方法
> 属性可以让对象存储数据，类方法则可以让对象执行任务

> 方法是在类中声明的特殊函数，方法声明类似与函数声明

> 可以使用->连接对象变量和方法名来调用方法。

> [demo002](./demo/类与对象/002.php)

# 不要动态设定属性
> 在创建类的时候就已经定义了数据类型，说明这个类是由特定的字段和函数集合组成。

> PHP允许动态设置属性，所以如果拼错或忘记属性名时并不会得到警告

> 通过Zend Studio 生成set、get方法

> ![](./demo/类与对象/003.png)

> [demo003](./demo/类与对象/003.php)

# 构造函数
> 当创建对象时，构造函数会被自动调用，构造方法可以确保必要的属性被设置，并完成任何需要准备的工作。

> 构造方法命名为\_\_construct()

> php4 不会把\_\_construct当作构造函数,可以通过声明一个和类的名称相同的方法来创建一个构造方法。

> [demo004](./demo/类与对象/004.php)

# 析构函数
> \_\_destruct() 它只在对象被垃圾收集器收集前(即对象从内存中删除之前)自动调用。

> [demo004](./demo/类与对象/004.php)

# 参数类型限定
> 对象方法的参数可是是任何类型的，也包括是对象类型。

> 当参数为对象类型时，很容易照成问题，所以PHP5引入了类的方法参数类型定义

> [demo005](./demo/类与对象/005.php)

# 继承
> 继承是从一个基类得到一个或多个派生类的机制。

> 继承自另一个类的类被称为该类的子类，通常可以用父亲和孩子来比喻。

> 继承将继承父亲的特性，这些特性由方法和属性组成。

> 子类可以增加父亲之外的新功能，因此子类也称为父类的扩展

> 如果子类中定义了构造函数则不会调用其父类的构造函数。

> [demo006](./demo/类与对象/006.php)

# 类的重写和重载
> PHP只支持类的方法重写，不支持重载，重载：方法名相同，但是参数个数不同。

> [demo006](./demo/类与对象/006.php)

# 属性和方法访问控制
> 类中元素可以声明public,private,protected

> 在任何地方都可以访问public属性和方法

> 只能在当前类中才能访问private方法和属,即使在子类中也不能访问。

> 可以在当前类中或子类中访问protected方法或属性，其他外部代码无权访问

> [demo007](./demo/类与对象/007.php)

# 访问控制好处
> 可见性关键字允许我们只公开类中客户需要的部分，这给对象设置了一个清晰的接口。
  通过阻止客户访问特定的属性，访问控制也助于预防代码中的bug

# 静态属性和方法
> 可以通过对象访问方法和属性，还可以通过类来访问它们，这样的方法和属性是“静态的” 必须用static关键字来声明

> 静态方法是以类作为作用域的函数，静态方法不能访问这个类的普通属性，因为那些属性属于一个对象，但可以访问静态属性。

> 如果修改了一个静态属性，那么这个类的所有实例都能访问到这个新值。

> PHP5.3.0之后，我们可以用一个变量来动态调用类。但该变量的值不能为关键字self, parent 或static。

> [demo008](./demo/类与对象/008.php)

# 常量属性
> 有些属性不能改变，虽然他们是公共的、可静态访问的、但客户端是不能改变它们。

> 常量属性只包含基本数据类型，不能将一个对象指派给常量，和静态方法一样，只能通过类而不能通过对象来访问。

> [demo009](./demo/类与对象/009.php)

# 对象的克隆
> 对象的赋值是传引用的，如果想复制一个完全一样

> [demo010](./demo/类与对象/010.php)

# 类和方法的final
> 如果父类中的方法被声明为final，则子类无法覆盖该方法； 如果一个类被声明为final，则不能被继承。

> [demo011](./demo/类与对象/011.php)

# 抽象类
> 抽象类不能被直接实例化

> 抽象类中只定义(或部分实现子类需要的方法)，子类可以继承它并且通过实现其中的抽象方法，使抽象类具体化。

> 大多数情况下，抽象类至少包含一个抽象方法，抽象方法用abstract关键字声明，其中不能有具体内容。

> 所有继承抽象类的孩子必须实现抽象类里面的抽象方法

> [demo012](./demo/类与对象/012.php)
> [demo013](./demo/类与对象/013.php)

# 接口
> 抽象类提供了具体的实现标准，而接口则是纯粹的模版，接口只能定义功能，而不包含实现的内容，

> 接口可以用关键字interface来声明，接口可以包含属性和方法的声明，但是方法体为空。

> [demo014](./demo/类与对象/014.php)

# 接口的实现
> 一个类可以使用implements来实现多个接口，实现接口后必须实现所有接口里的抽象方法

> 一个类可以先继承某个类或抽象类，在实现N个接口

> [demo014](./demo/类与对象/014.php)

# 自动加载
> 可以定义一个 __autoload 函数，它会在试图使用尚未被定义的类时自动调用。

> 通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类

> [demo015](./demo/类与对象/015.php)

# 对象迭代
> PHP5提供了一种迭代（iteration）对象的功能，就像使用数组那样，可以通过foreach 来遍历对象中的属性。

> 默认情况下，在外部迭代只能得到外部可见的属性的值。

> [demo016](./demo/类与对象/016.php)

# 魔术方法 \_\_call,\_callStatic
> \_\_call($method,$arg_array) 调用未定义的方法时被调用

> \_\_callStatic($method,$arg_array) 调用未定义的静态方法时被调用

> [demo017](./demo/类与对象/017.php)

# 魔术方法 \_\_get,\_\_set
> \_\_get($property) 访问未定义的属性时被调用

> \_\_set($property,$value)设定未定义的属性时被调用

> [demo017](./demo/类与对象/017.php)

# 魔术方法 \_\_isset,\_\_unset
> \_\_isset($property) 对未定义属性调用isset()时被调用

> \_\_unset($property)对未定义属性调用unset()时使用被调用

> [demo017](./demo/类与对象/017.php)

# 魔术方法 \_\_sleep,\_\_wakeup
> serialize() 函数会检查是否存在一个魔术方法 \_\_sleep().如果存在，\_\_sleep()方法会先被调用， 然后才执行序列化操作

> \_\_wakeup()经常用在反序列化操作中

> [demo017](./demo/类与对象/017.php)

# 魔术方法 \_\_toString
> \_\_toString() 当打印一个对象时，会使用该方法

> [demo017](./demo/类与对象/017.php)

# 魔术方法 \_\_invoke
> 当尝试以调用函数的方式调用一个对象时，魔术方法 \_\_invoke() 方法会被自动调用。

> [demo017](./demo/类与对象/017.php)

# 魔术方法 \_\_set\_state
> 当调用 var\_export()时，这个静态方法会被调用

> var_export 输出或返回一个变量的字符串表示，它和 var\_dump() 类似，不同的是其返回的表示是合法的 PHP 代码。

> 配合eval和clone功能差不多，但是可以做到有选择性的克隆

> [demo017](./demo/类与对象/017.php)

# 魔术方法 \_\_clone
> 当克隆一个对象时会调用该方法

> [demo017](./demo/类与对象/017.php)

# 后期静态绑定
> PHP 5.3 增加了一个叫做后期静态绑定的功能，用于在继承范围内引用静态调用的类，被命名为”后期静态绑定“

> 后期绑定表示，static::不再被解析为定义当前方法所在的类，而是在实际运行时计算的。

> [demo018](./demo/类与对象/018.php)

# Traits
> Traits是在5.4中新增的一个用于实现代码重用的方法。

> php是一种单一继承的语言，我们无法像java一样在一个class中extends多个基类来实现代码重用，Traits能解决这一代码重用的问题，

> Traits和class在语义的定义上都是为了减少代码的复杂性，避免多重继承的问题。

> Traits 和class相似，在Traits内部无法进行实例化，即不存在类似class的构造函数__construct()。

> Traits作为一个php传统继承的扩展并实现水平集成;因此在应用程序的class中可以不再需要继承。

> [demo019](./demo/类与对象/019.php) [demo020](./demo/类与对象/020.php) [demo021](./demo/类与对象/021.php) [demo022](./demo/类与对象/022.php) [demo023](./demo/类与对象/023.php)
</textarea>